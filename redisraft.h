#ifndef _REDISRAFT_H
#define _REDISRAFT_H

#include <stdint.h>
#include <stdbool.h>
#include <sys/queue.h>
#include <stdio.h>

#define REDISMODULE_EXPERIMENTAL_API
#include "uv.h"
#include "hiredis/hiredis.h"
#include "hiredis/async.h"
#include "redismodule.h"
#include "raft.h"

#define NODE_CONNECTED      1
#define NODE_CONNECTING     2

/* --------------- RedisModule_Log levels used -------------- */

#define REDIS_WARNING   "warning"
#define REDIS_NOTICE    "notice"


/* -------------------- Logging macros -------------------- */

/*
 * We use our own logging mechanism because most log output is generated by
 * the Raft thread which cannot use Redis logging.
 */

extern int redis_raft_loglevel;
extern FILE *redis_raft_logfile;

#define LOGLEVEL_ERROR           0
#define LOGLEVEL_INFO            1
#define LOGLEVEL_VERBOSE         2
#define LOGLEVEL_DEBUG           3

#define LOG(level, fmt, ...) \
    do { if (redis_raft_loglevel >= level) \
            fprintf(redis_raft_logfile, fmt, ##__VA_ARGS__); \
    } while(0)

#define LOG_ERROR(fmt, ...) LOG(LOGLEVEL_ERROR, fmt, ##__VA_ARGS__)
#define LOG_INFO(fmt, ...) LOG(LOGLEVEL_INFO, fmt, ##__VA_ARGS__)
#define LOG_VERBOSE(fmt, ...) LOG(LOGLEVEL_VERBOSE, fmt, ##__VA_ARGS__)
#define LOG_DEBUG(fmt, ...) LOG(LOGLEVEL_DEBUG, fmt, ##__VA_ARGS__)

#define TRACE(fmt, ...) LOG(LOGLEVEL_DEBUG, "%s:%d: " fmt, __FILE__, __LINE__, ##__VA_ARGS__)

#define NODE_LOG(level, node, fmt, ...) \
    LOG(level, "node:%u: " fmt, (node)->id, ##__VA_ARGS__)

#define NODE_LOG_ERROR(node, fmt, ...) NODE_LOG(LOGLEVEL_ERROR, node, fmt, ##__VA_ARGS__)
#define NODE_LOG_INFO(node, fmt, ...) NODE_LOG(LOGLEVEL_INFO, node, fmt, ##__VA_ARGS__)
#define NODE_LOG_VERBOSE(node, fmt, ...) NODE_LOG(LOGLEVEL_VERBOSE, node, fmt, ##__VA_ARGS__)
#define NODE_LOG_DEBUG(node, fmt, ...) NODE_LOG(LOGLEVEL_DEBUG, node, fmt, ##__VA_ARGS__)

typedef struct {
    void *raft;                 /* Raft library context */
    RedisModuleCtx *ctx;        /* Redis module thread-safe context; only used to push commands
                                   we get from the leader. */
    bool running;               /* Thread is running */
    uv_thread_t thread;         /* Raft I/O thread */
    uv_loop_t *loop;            /* Raft I/O loop */
    uv_async_t rqueue_sig;      /* A signal we have something on rqueue */
    uv_timer_t ptimer;          /* Periodic timer to invoke Raft periodic function */
    uv_mutex_t rqueue_mutex;    /* Mutex protecting rqueue access */
    STAILQ_HEAD(rqueue, RaftReq) rqueue;     /* Requests queue (from Redis) */
} RedisRaftCtx;

/* Node address specifier. */
typedef struct node_addr {
    uint16_t port;
    char host[256];             /* Hostname or IP address */
} NodeAddr;

typedef struct NodeConfig {
    int id;
    NodeAddr addr;
    struct NodeConfig *next;
} NodeConfig;

typedef struct {
    int id;                 /* Local node Id */
    NodeAddr addr;          /* Address of local node, if specified */
    NodeConfig *nodes;      /* Nodes to talk to */
    /* Flags */
    bool init;
} RedisRaftConfig;

typedef struct {
    int id;
    int state;
    NodeAddr addr;
    redisAsyncContext *rc;
    uv_getaddrinfo_t uv_resolver;
    uv_tcp_t uv_tcp;
    uv_connect_t uv_connect;
    RedisRaftCtx *rr;
} Node;

struct RaftReq;
typedef int (*RaftReqHandler)(RedisRaftCtx *, struct RaftReq *);

enum RaftReqType {
    RR_CFGCHANGE_ADDNODE = 1,
    RR_CFGCHANGE_REMOVENODE,
    RR_APPENDENTRIES,
    RR_REQUESTVOTE,
    RR_REDISCOMMAND,
    RR_INFO
};

extern RaftReqHandler g_RaftReqHandlers[];

#define RR_PENDING_COMMIT 1

typedef struct {
    int id;
    NodeAddr addr;
} RaftCfgChange;

typedef struct {
    int argc;
    RedisModuleString **argv;
} RaftRedisCommand;

typedef struct RaftReq {
    int type;
    int flags;
    STAILQ_ENTRY(RaftReq) entries;
    RedisModuleBlockedClient *client;
    RedisModuleCtx *ctx;
    union {
        RaftCfgChange cfgchange;
        struct {
            int src_node_id;
            msg_appendentries_t msg;
        } appendentries;
        struct {
            int src_node_id;
            msg_requestvote_t msg;
        } requestvote;
        struct {
            RaftRedisCommand cmd;
            msg_entry_response_t response;
        } redis;
    } r;
} RaftReq;

/* node.c */
void NodeFree(Node *node);
Node *NodeInit(int id, const NodeAddr *addr);
void NodeConnect(Node *node, RedisRaftCtx *rr);
bool NodeAddrParse(const char *node_addr, size_t node_addr_len, NodeAddr *result);
bool NodeConfigParse(RedisModuleCtx *ctx, const char *str, NodeConfig *c);

/* raft.c */
void RaftRedisCommandSerialize(raft_entry_data_t *target, RaftRedisCommand *source);
bool RaftRedisCommandDeserialize(RedisModuleCtx *ctx, RaftRedisCommand *target, raft_entry_data_t *source);
void RaftRedisCommandFree(RedisModuleCtx *ctx, RaftRedisCommand *r);
int RedisRaftInit(RedisModuleCtx *ctx, RedisRaftCtx *rr, RedisRaftConfig *config);
int RedisRaftStart(RedisModuleCtx *ctx, RedisRaftCtx *rr);

void RaftReqFree(RaftReq *req);
RaftReq *RaftReqInit(RedisModuleCtx *ctx, enum RaftReqType type);
void RaftReqSubmit(RedisRaftCtx *rr, RaftReq *req);
void RaftReqHandleQueue(uv_async_t *handle);

/* util.c */
int RedisModuleStringToInt(RedisModuleString *str, int *value);
char *catsnprintf(char *strbuf, size_t *strbuf_len, const char *fmt, ...);

#endif  /* _REDISRAFT_H */
